## About 回溯算法
### 概览
* 号称算法百科大全的《算法导论》里似乎没看到关于回溯的章节~~，网上好像也没有很透彻的讲解（解释其时间空间复杂度），不知为何。
  * => 《算法设计与分析》给了些解释，就是此类问题太难。原文是这样写的"无论从理论角度还是实践角度看，组合问题都是计算机领域中最难的问题。
  第一，通常虽则问题规模的增大，组合对象的数量增长极快，会到达不可思议的量级；第二，没有一种已知算法能在可接受的时间内，精确地解决绝大多
  这类问题。"
  * => leetcode中这类问题，N的规模通常限制地比较小（难怪了）
  
* leetcode上此类题目倒是很多，实际面试中也不少见...

### 性能分析
* [算法设计与分析之回溯法](https://www.361shipin.com/blog/1505779839624351745)，这篇文章算是讲得比较细致。
* 排列问题的时间复杂度：N!；组合和子集问题是2^N；整体上性能开销是非常绝大的，指数级。

### 解题思路
* 套用回溯的解题模版：
````
  void backtracking(参数) {
  if (终止条件) {
  存放结果;
  return;
  }

  for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
  处理节点;
  backtracking(路径，选择列表); // 递归
  回溯，撤销处理结果
  }
  }
````
能解大部分的问题，且代码也很简洁；
* 不过需要注意：性能问题！有些题目如果有更优的思路，则不必用回溯，比如贪心。

### 主要题型
* 主要是排列、组合、子集这几类；
* 还有经典的N皇后问题（估计太难，一般面试不好考到）；

### 题目解析
##### 排列问题
* [46. Permutation](https://leetcode.com/problems/permutations-ii/) . n全排列。终止条件和约束条件都很明确。写起来简单。（借助额外的数组也可以实现）
* [47. Permutations II](https://leetcode.com/problems/permutations-ii/). 上题的进阶，可包含重复元素。如何减枝是关键。朴素的做法是在结果集和去重，不过效率太低。
上题有借助额外数组的解法后，此题重复元素的跳过，会更容易想到。
* [60. Permutation Sequence](https://leetcode.com/problems/permutation-sequence/).看着简单，套用46题的（有序）回溯 很容易解。但是此题作为Hard是
有原因的。就是回溯会超时... 得通过排列组合的数学特性来解。

##### 子集问题
* [78. Subsets](https://leetcode.com/problems/subsets/). 和排列不同，子集没有元素顺序。因此不能和排列一样，每一轮回溯都遍历所有元素。通过分析例子，还是能比较容易想
到递增序的解法（不同顺序的排列在这里是相同子集，需要绕开；为了绕开不同顺序的全排列，可想到此解法）。
* [90. Subsets II](https://leetcode.com/problems/subsets-ii/). 上题的进阶，包含重复元素。关键点在于递增序中，判断该元素是否应该加入。通过分析例子，可知后续的重复
元素应该绕过（前面相同元素求子集时已经包含）

##### 组合问题
