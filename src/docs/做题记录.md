#### 贪心算法
##### [1024. Video Stitching](https://leetcode.com/problems/video-stitching/)
###### 解题 Round One 
* 做题时间: 2022-08-28 
* 耗时：1h 
* 某轮校招面试的考题，知道用贪心算法来解。期间debug至少3次才AC，各种临时变量，边界检查，代码变得很臃肿...
* 实际上，解题思路还是比较清晰的：每一轮选取区间范围内的，跨度最大的即可。

###### 解题 Round Two
* 针对Round One做了如下优化：
  * 每一轮取跨度最大即寻找end值最大的即可，不需要减法判断，因此maxRange替换为一个Math.max操作即可；同时去除冗余的临时变量maxRange；
  * 把curTime < time的判断，放到循环体中;
  * 代码量减少1/3 （30行 -> 20行）；
* 存在的问题：仍旧有不少边界判断；另外tempCurTime变量看着还是非常冗余；

###### 讨论区解法
* 参考[链接](https://leetcode.com/problems/video-stitching/discuss/269988/C%2B%2BJava-6-lines-O(n-log-n))
* 实在是精妙。本质差别是循环体的设计就不一样，curTime < time。这么看来，原有解法中两层循环体的索引设计其实是不合理的。
* 相同的解题算法，代码精简3倍...
* 核心还是对题目的理解，映射到代码的实现。怎么用好for循环，还是有讲究的。。。

##### ##### [39. Combination Sum](https://leetcode.com/problems/combination-sum/)
* 做题时间：2022-09-04
* 常见的面试题

###### Round One
* 解法：dfs 回溯 
* 耗时：大概15min？一遍写出来的。
* 结果：因为之前刷过类似排列的题目（补充下），dfs回溯是比较简单直接的思路，没想到是超时了...看来得考虑dp的解法，这样一来难度比预想的大了，难怪是个hard的题
* 尝试优化：在收集到k个结果时提前中止dfs，平均时间有提升。不过最坏情况下还是会超时；
* 问题点：性能不足；另外初始化数组是否必要？

###### Round Two
* 解法：dp 
* 结果：没做出来...//反而引入2个问题：
  * 1.是通过dp[i]求解dp[i+1]时，需要遍历每一个str，在str的每个位置插新的数值；
  * 2.前序步骤没法保序，暂时想不到解决办法；3.该解法的性能并没有比上一个解法更优；


###### Round Three 
* 解法：利用排列组合的特性，参考[LeetCode四道Permutations问题详解](https://blog.csdn.net/Jacky_chenjp/article/details/66477538)
以及讨论区的解法。构造全排列的状态转移方程（即怎么从n-1推算出n的有序全排列）.
* 思路有了后，编码就很简单了...前面两种解法相比起来相形见绌（一方面是性能差，另外是穷举有点low-.-）
* 心得: 高质量的hard题，还是很有挑战的，刷一刷很有意义。