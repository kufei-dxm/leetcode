 记录主要题型的关键解题思路

### 题目类型
#### 回溯
* 典型场景：类似穷举类型的题目。比如
* 解题思路：发现树遍历DFS的思路可以推广到这类穷举类型的回溯题目中，主要需要处理好递归式。另外一个是回溯回退时需要清理状态。

#### 动态规划

* 典型场景：最长递增子序列、最大子数组、最小编辑距离、背包问题、凑零钱问题； 核心思想包括拆分子问题，记住过往，减少重复计算。
* 解题思路：穷举分析，确定边界，找出规律+确定最优子结构，写出状态转移方程；
    [看一遍就理解：动态规划详解 ](https://juejin.cn/post/6951922898638471181#heading-15) 写的不错
* 题目列表：
    * [300. Longest Increasing Subsequence](https://leetcode.com/problems/longest-increasing-subsequence/)。最长递增子序列。
        * 常规解法：设计dp[i] = 以i结尾的最长递增子序列。每次i递增时，需要循环遍历i之前的dp[i]，找到小于i位置值的最长序列，然后+1; 复杂度是n的平方。
        * 精妙解法：dp[i] = ...其实不太容易想到。。。
    * [53. Maximum Subarray](https://leetcode.com/problems/maximum-subarray/)。和最大的连续子数组。设计一个子结构：subSet[i] = i位置结束的最大值，即可迎刃而解。 
    * [152. Maximum Product Subarray](https://leetcode.com/problems/maximum-product-subarray/), 乘积最大的连续子数组。需要考虑负负得正的情况，因此需要辅助dpMin数组。
    * [139. Word Break](https://leetcode.com/problems/word-break/).子结构不像数组类型的题目那么明显。

#### 排序和搜索
* 题目列表：
    * 解题思路：反向遍历；借住Map等结构，过程中可巧妙使用Map-Array。
    * 节点复杂的题目，感觉不太会考到。因为裸写排序代码会很复杂，不排序处理代码更复杂。。。而通常通过库函数sort一下后再处理会简单很多。。
    * [88. Merge Sorted Array](https://leetcode.com/problems/merge-sorted-array/)。谁说数组不能后向遍历的？
    * [347. Top K Frequent Elements](https://leetcode.com/problems/top-k-frequent-elements/)。数组->Map->数组，多种结构组合，巧解问题。
    
#### 链表
* 解题思路：
    * 配合多个指针也有奇效。
    * 递归法解链表问题，代码可做到非常简洁。如题[21. Merge Two Sorted Lists](https://leetcode.com/problems/merge-two-sorted-lists/)
    * 神奇的解题思路。如题[160. Intersection of Two Linked Lists](https://leetcode.com/problems/intersection-of-two-linked-lists/)
    
#### 数组和字符串
* 解题思路：
    * 配合多个指针进行遍历；正向遍历配合反向遍历。如：删除数组中的重复元素、字符串反转等。  
    * stack数据结构的妙用。如题[20. Valid Parentheses](https://leetcode.com/problems/valid-parentheses/) 
#### 回文相关
* 包括：
    * 字符串/数组的回文。比较简单，头尾指针循环比较即可。
    * 链表的回文（如题 [234](https://leetcode.com/problems/palindrome-linked-list/)）。解题思路是快慢指针，然后原地反转链表的后半段。
    * 数字的回文。
    
